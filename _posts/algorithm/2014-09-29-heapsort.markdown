---
layout: post
category: "algorithm"
title:  "堆排序"
tags: [algorithm|sort]
---
####1.基本概念
堆类似一个完全二叉树，数组存储，下标规则：

- parent(i) = i/2 
- left(i) = 2i
- right(i) = 2i+1

btw，下标也可以通过移位操作获得，child左移，father右移；

最大堆：A[parent(i)] >= A[i]，最小堆相反；

维护堆性质MAX-HEAPIFY：让A[i]在最大堆中逐渐下降；O(lgN)

####2.算法
{% highlight java %}
MAX-HEAPIFY(A,i)
  l = left(i)
  r = right(i)
  if l <= A.heapsize and A[l]>A[i]
    largest = l
  else
    largest = i
  if r <=A.heapsize and A[r]>A[largest]
    largest = r
  if largest != i
    exchange A[i] with A[largest]
    MAX-HEAPIFY(A,largest)
{% endhighlight %}
建立堆：对除了叶子之外的节点执行MAX-HEAPIFY，O(n)
{% highlight java %}
BUILD-MAX-HEAPIFY(A)
  A.heapsize = A.length
  for i = A.length/2 downto 1
    MAX-HEAPIFY(A,i)
{% endhighlight %}
堆排序算法：交换root和末尾节点，在n-1上继续构建堆
{% highlight java %}
HEAPSORT(A)
  BUILD-MAX-HEAP(A)
  for i = A.length downto 2
    exchange A[1] with A[i]
    A.heapsize--
    MAX-HEAPIFY(A,1)
{% endhighlight %}

{% highlight java %}
private static int[] a = { 99, 5, 36, 7, 22, 17, 46, 12, 2, 19, 25, 28, 1,
            92 };
private static int n = 14;
public static void main(String[] args) {
    createHeap();
    heapsort();
}
private static void createHeap() {
    for (int i = a.length / 2; i >= 0; i--) {
        heapify(i);
    }
}
private static void heapsort() {
    while (n > 0) {
        n--;
        swap(0, n);
        heapify(0);
    }
}
private static void heapify(int i) {
    boolean flag = true;
    int temp = i;
    while (i * 2 +1< n && flag) {
        if (a[i] > a[i * 2+1 ]) {
            temp = i * 2+1 ;
        }
        if (i * 2 + 2 < n && a[temp] > a[i * 2 + 2]) {
            temp = i * 2 + 2;
        }
        if (i != temp) {
            swap(i, temp);
            i = temp;
        } else {
            flag = false;
        }
    }
}
private static void swap(int i, int j) {
    int t = a[i];
    a[i] = a[j];
    a[j] = t;
}  
{% endhighlight %}