---
layout: post
category: "design"
title:  "策略模式-Strategy"
tags: [design|factory]
---
>问题：如何让算法和对象分开来，使得算法可以独立于使用它的客户而变化？
>解决方案：定义一系列的算法,把每一个算法封装起来, 并且使它们可相互替换。
>适用场景：
1.许多相关的类仅仅是行为有异。 “策略”提供了一种用多个行为中的一个行为来配置一个类的方法。动态地在几种算法中选择一种；
2.需要使用一个算法的不同变体；
3.算法使用客户不应该知道的数据；
4.一个类定义了多种行为 , 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。
>模式组成：
Context：持有一个Strategy的接口对象；可以有一setStrategy的方法，用来动态改变策略；如Duck类持有的fly和quark对象(HeadFirst)；
抽象策略接口Strategy，定义算法的公共接口；
具体策略类，实现接口；
具体的Context，如实例化的Duck，设置具体的策略，并取得对应的行为。
![pic](/images/pic/strategy.png)
>看一个例子，内容来源[programcreek](http://www.programcreek.com/2011/01/a-java-example-of-strategy-design-pattern/)
>Mike驾车超速，好警察和严厉警察有不同的评判策略。
![pic2](http://www.programcreek.com/wp-content/uploads/2011/01/strategy-pattern-class-diagram.jpg)
{% highlight java %}
public interface Strategy {
	//defind a method for police to process speeding case.
	public void processSpeeding(int speed);
}
public class NicePolice implements Strategy{
	@Override
	public void processSpeeding(int speed) {
		System.out.println("This is your first time, be sure don't do it again!");		
	}
}
public class HardPolice implements Strategy{
	@Override
	public void processSpeeding(int speed) {
		System.out.println("Your speed is "+ speed+ ", and should get a ticket!");
	}
}
public class Situation {
	private Strategy strategy;
 
	public Situation(Strategy strategy){
		this.strategy = strategy;
	}
 
	public void handleByPolice(int speed){
		this.strategy.processSpeeding(speed);
	}
}
{% endhighlight %}
>策略模式和状态模式很相似。主要的不同是策略在不同情况下使用不同的算法，而状态是改变对象的行为。